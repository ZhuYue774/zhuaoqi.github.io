<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring回顾之一]]></title>
    <url>%2F2017%2F05%2F28%2FSpring%E4%B9%8BIOC%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一.基础准备1.IoC是什么Ioc—Inversion of Control，即“控制反转”，不是什么技术，一种设计思想。 传统的Java编程中，如果应用程序需要依赖对象，需要通过new来实现。在IoC中，所有的设计好的对象都是通过容器进行控制的。下面需要理解几个问题： 谁控制谁，控制什么：IoC容器控制对象的创建。控制什么，主要是控制外部资源的获取（不仅限于对象）。 为何是反转：传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象。为何是反转？因为容器帮我们查看和注入依赖对象，对象被动的接受依赖对象。 2.DI是什么DI—Dependency Injection，即“依赖注入”：是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。通过依赖注入我们可以简单的通过配置或者是注解，即可为目标对象注入需要的资源，完成自身的业务逻辑。 3.Bean的概念由IoC容器管理的组成应用程序的对象就叫Bean，Bean是由Spring容器（IoC容器）进行初始化，装配以及管理的对象。 二.Spring入门 详解IoC容器 在spring中IoC容器的代表就是org.springframework.beans中的BeanFactory接口，BeanFactory提供了IoC容器的基本功能；在org.springframework.context下的ApplicationContext扩展了BeanFactory（BeanFactory继承了ListableBeanFactory接口，而ListableBeanFactory继承了BeanFactory接口），还提供了与Spring AOP的集成、国际化处理、事件的传播和提供不同层次的context实现。综上：BeanFactory提供了IoC容器的基本功能，而ApplicationContext提供了更多企业级功能的支持。BeanFactory容器一览： XmlBeanFactory：BeanFactory实现，提供基本的IoC容器功能，可以从classpath或文件系统等获取资源； 123456File file = new File(&quot;fileSystemConfig.xml&quot;);Resource resource = new FileSystemResource(file);BeanFactory beanFactory = new XmlBeanFactory(resource); Resource resource = new ClassPathResource(&quot;classpath.xml&quot;); BeanFactory beanFactory = new XmlBeanFactory(resource); ClassPathXmlApplicationContext：ApplicationContext实现，从classpath获取配置文件； 1BeanFactory beanFactory = new ClassPathXmlApplicationContext(&quot;classpath.xml&quot;); FileSystemXmlApplicationContext：ApplicationContext实现，从文件系统获取配置文件。 1BeanFactory beanFactory = new FileSystemXmlApplicationContext(&quot;fileSystemConfig.xml&quot;); IoC容器执行流程 首先是在配置文件中声明Bean的定义，为Bean配置元数据。 由IoC容器的Bean Reader读取并解析配置文件，通过BeanDefinition配置元数据，IoC容器根据BeanDefinition进行实例化、配置以及组装Bean。 由应用程序实例化IoC容器，得到Bean对象。 小案例测试 创建接口 123public interface IHelloSpring &#123; public void sayHello();&#125; 创建实现类 12345public class HelloSpringImpl implements IHelloSpring &#123; void sayHello() &#123; System.out.println(&quot;Hello Spring&quot;); &#125;&#125; 配置文件 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;hello&quot; class=&quot;com.study.hello.HelloSpringImpl&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 编写测试代码 12345678910111213public class HelloSpringTest &#123; @Test public void test()&#123; ApplicationContext context= new ClassPathXmlApplicationContext(&quot;classpath:HelloSpring.xml&quot;); //从容器中获取bean，面向接口编程 IHelloSpring hello = context.getBean(&quot;hello&quot;, IHelloSpring.class); IHelloSpring hello1 = (IHelloSpring) context.getBean(&quot;hello&quot;); hello.sayHello(); hello1.sayHello(); &#125;&#125; 小结 在测试代码中除了程序的入口，其他的地方没有Spring的任何组件，也没有实现Spring框架的任何接口。在代码编写完全是面向接口编程的，使用时不需要知道接口的实现类，需要修改实现类时，可以通过配置文件进行修改。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate回顾一]]></title>
    <url>%2F2017%2F02%2F28%2FHibernate%E5%9B%9E%E9%A1%BE%E4%B8%80%2F</url>
    <content type="text"><![CDATA[什么是Hibernate: Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的 orm框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用，最具革命意义的是，Hibernate可以在应用EJB的J2EE架构中取代CMP，完成数据持久化的重任。 Hibernate 位于持久层 对象关系映射:(ORM) ORM：Object Relational Mapping。 对象关系映射。开发语言用的是Java，面向对象的（Object）。使用的数据库是关系型数据库（Relational）。就是将对象与数据库中的表建立一种映射关系，操作对象就可以操作这个表。 Hibernate 入门: 下载 Hibernate 下载地址：https://sourceforge.net/projects/hibernate/files/hibernate-orm/5.0.7.Final/ 下载完Hibernate并解压后,目录中包含一系列的子目录,这些子目录分别用于存放不同功能的文件,主要如下: documentation 文件夹: 存放 Hibernate 的相关文档,包括参考文档、API文档。 lib文件夹： 存放 Hibernate 编译和运行所依赖的包。其中require子目录下包含了运行 Hibernate 项目的 jar 包。 project文件夹： 存放 Hibernate 相关源代码。 导入相关包(搭建环境) a. Hibernate 包 D:\hibernate-release-5.0.7.Final\lib\required\ 下所有jar包 b. 日志记录包 log4j-1.2.16.jar slf4j-api-1.6.1.jar slf4j-log4j12-1.7.2.jar c. 数据库驱动包 mysql-connector-java-5.1.7-bin.jar 建立数据库及表 12345678910 CREATE TABLE `cst_customer` ( `cust_id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT '客户编号(主键)', `cust_name` varchar(32) NOT NULL COMMENT '客户名称(公司名称)', `cust_source` varchar(32) DEFAULT NULL COMMENT '客户信息来源', `cust_industry` varchar(32) DEFAULT NULL COMMENT '客户所属行业', `cust_level` varchar(32) DEFAULT NULL COMMENT '客户级别', `cust_phone` varchar(64) DEFAULT NULL COMMENT '固定电话', `cust_mobile` varchar(16) DEFAULT NULL COMMENT '移动电话', PRIMARY KEY (`cust_id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 创建实体类 持久化类是应用程序中的业务实体类，这里的持久化是指类的对象能够被持久化保存到数据库中。Hibernate 使用普通 Java 对象，（Plain Old Java Object），即 POJO 的编程模式来进行持久化。POJO 类中包含的是与数据库表相对应的各个属性，这些属性通过 gitter 和 setter 方法来访问，对外部隐藏了内部的实现细节。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 public class Customer &#123; private Long cust_id; private String cust_name; private String cust_source; private String cust_industry; private String cust_level; private String cust_phone; private String cust_mobile; public Long getCust_id() &#123; return cust_id; &#125; public void setCust_id(Long cust_id) &#123; this.cust_id = cust_id; &#125; public String getCust_name() &#123; return cust_name; &#125; public void setCust_name(String cust_name) &#123; this.cust_name = cust_name; &#125; public String getCust_source() &#123; return cust_source; &#125; public void setCust_source(String cust_source) &#123; this.cust_source = cust_source; &#125; public String getCust_industry() &#123; return cust_industry; &#125; public void setCust_industry(String cust_industry) &#123; this.cust_industry = cust_industry; &#125; public String getCust_level() &#123; return cust_level; &#125; public void setCust_level(String cust_level) &#123; this.cust_level = cust_level; &#125; public String getCust_phone() &#123; return cust_phone; &#125; public void setCust_phone(String cust_phone) &#123; this.cust_phone = cust_phone; &#125; public String getCust_mobile() &#123; return cust_mobile; &#125; public void setCust_mobile(String cust_mobile) &#123; this.cust_mobile = cust_mobile; &#125;&#125; 创建映射文件 1234567891011121314151617181920212223 &lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt; &lt;!-- ORM:Object Relational Mapping,将实体类O和数据库的表R 建立映射关系 --&gt; &lt;class name="com.cc.hibernate.domain.Customer" table="cst_customer"&gt; &lt;!-- 类中的属性与表中的主键对应 --&gt; &lt;id name="cust_id" column="cust_id"&gt; &lt;generator class="native"/&gt; &lt;/id&gt; &lt;!-- 类中的属性与表中的字段对应 --&gt; &lt;property name="cust_name" column="cust_name"/&gt; &lt;property name="cust_source" column="cust_source"/&gt; &lt;property name="cust_industry" column="cust_industry"/&gt; &lt;property name="cust_level" column="cust_level"/&gt; &lt;property name="cust_phone" column="cust_phone"/&gt; &lt;property name="cust_mobile" column="cust_mobile"/&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; 映射文件通常有一个命名规则：类名.hbm.xml 创建 Hibernate 的核心配置文件 123456789101112131415161718192021222324 &lt;!DOCTYPE hibernate-configuration PUBLIC"-//Hibernate/Hibernate Configuration DTD 3.0//EN""http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt; &lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 连接数据库的信息 --&gt; &lt;property name="hibernate.connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="hibernate.connection.url"&gt;jdbc:mysql:///hibernate_day01&lt;/property&gt; &lt;property name="hibernate.connection.username"&gt;root&lt;/property&gt; &lt;property name="hibernate.connection.password"&gt;123&lt;/property&gt; &lt;!-- 数据库的方言:根据底层的数据库生成不同的SQL --&gt; &lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 配置显示SQL --&gt; &lt;property name="hibernate.show_sql"&gt;true&lt;/property&gt; &lt;!-- 配置格式化SQL --&gt; &lt;property name="hibernate.format_sql"&gt;true&lt;/property&gt; &lt;!-- 配置hbm2ddl --&gt; &lt;property name="hibernate.hbm2ddl.auto"&gt;update&lt;/property&gt; &lt;!-- 加载映射文件 --&gt; &lt;mapping resource="com/cc/hibernate/domain/Customer.hbm.xml"/&gt; &lt;/session-factory&gt; &lt;/hibernate-configuration&gt; 编写测试代码 123456789101112131415161718192021222324252627 public class HibernateDemo1 &#123; @Test /** * 保存操作 */ public void demo1()&#123; // 加载Hibernate的核心配置文件. Configuration configuration = new Configuration().configure(); // 创建一个SessionFactory的对象. SessionFactory sessionFactory = configuration.buildSessionFactory(); // 创建Session(相当于JDBC中的Connection) Session session = sessionFactory.openSession(); // 开启事务: Transaction transaction = session.beginTransaction(); // 完成操作： Customer customer = new Customer(); customer.setCust_name("小岳岳"); session.save(customer); // 提交事务 transaction.commit(); // 释放资源 session.close(); &#125;&#125;]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
        <tag>Java</tag>
        <tag>框架</tag>
      </tags>
  </entry>
</search>